<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Kinegratii的博客</title>
  <subtitle>你说有一日总会名扬天下实现你抱负</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://kinegratii.github.io/"/>
  <updated>2016-10-31T10:37:35.011Z</updated>
  <id>http://kinegratii.github.io/</id>
  
  <author>
    <name>Kinegratii</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>ionic安卓构建</title>
    <link href="http://kinegratii.github.io/2016/10/29/ionic-build-android/"/>
    <id>http://kinegratii.github.io/2016/10/29/ionic-build-android/</id>
    <published>2016-10-29T12:48:00.000Z</published>
    <updated>2016-10-31T10:37:35.011Z</updated>
    
    <content type="html"><![CDATA[<p>本文描述了ionic项目构建Android安装包的主要步骤。</p>
<a id="more"></a>
<h2 id="1-环境配置"><a href="#1-环境配置" class="headerlink" title="1 环境配置"></a>1 环境配置</h2><h3 id="1-1-添加Android平台"><a href="#1-1-添加Android平台" class="headerlink" title="1.1 添加Android平台"></a>1.1 添加Android平台</h3><p>执行  <code>ionic platform add android</code> 即可</p>
<h3 id="1-2-Java路径配置"><a href="#1-2-Java路径配置" class="headerlink" title="1.2 Java路径配置"></a>1.2 Java路径配置</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">PATH=path\to\bin\</div></pre></td></tr></table></figure>
<h3 id="1-3-Android环境配置"><a href="#1-3-Android环境配置" class="headerlink" title="1.3 Android环境配置"></a>1.3 Android环境配置</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ANDROID_HOME=你的SDK目录</div></pre></td></tr></table></figure>
<p>将 <code>%ANDROID_HOME%\tools\;%ANDROID_HOME%\platform_tools\</code> 加到PATH变量后面。</p>
<h2 id="2-Android自动签名"><a href="#2-Android自动签名" class="headerlink" title="2 Android自动签名"></a>2 Android自动签名</h2><h2 id="2-1-配置release-signing-properties文件"><a href="#2-1-配置release-signing-properties文件" class="headerlink" title="2.1 配置release-signing.properties文件"></a>2.1 配置release-signing.properties文件</h2><ol>
<li>在platforms\android目录新建名为release-signing.properties的文件，文件内容如下</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">storeFile=path/to/keystore</div><div class="line">keyAlias=your key alias</div><div class="line">storePassword=your store password</div><div class="line">keyPassword=your key password</div></pre></td></tr></table></figure>
<p>备注：在windows下storeFile文件路径应使用Unix下的目录分隔符 <code>/</code>。</p>
<h2 id="3-编译"><a href="#3-编译" class="headerlink" title="3 编译"></a>3 编译</h2><p>使用 <code>ionic build --release android</code> 编译即可，在\platforms\android\build\outputs\apk出现android-release.apk文件即是已签名的安装包。</p>
<h2 id="4-注意事项"><a href="#4-注意事项" class="headerlink" title="4 注意事项"></a>4 注意事项</h2><p>在升级到ionic2时，使用 <code>ionic build --release android</code> 可能会出现 <code>✗ You cannot run iOS unless you are on Mac OSX.</code>的错误，可改为 <code>ionic build android --release</code> 即可。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文描述了ionic项目构建Android安装包的主要步骤。&lt;/p&gt;
    
    </summary>
    
      <category term="编程" scheme="http://kinegratii.github.io/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="ionic" scheme="http://kinegratii.github.io/tags/ionic/"/>
    
  </entry>
  
  <entry>
    <title>新的起点</title>
    <link href="http://kinegratii.github.io/2016/10/28/first-post/"/>
    <id>http://kinegratii.github.io/2016/10/28/first-post/</id>
    <published>2016-10-28T05:48:54.000Z</published>
    <updated>2016-11-01T12:22:31.971Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>你说有一日总会名扬天下实现你抱负</p>
</blockquote>
<p>2016年10月28日，KgBlog改用<a href="https://hexo.io/" target="_blank" rel="external">hexo</a>构建，新的起点。</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;你说有一日总会名扬天下实现你抱负&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;2016年10月28日，KgBlog改用&lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;hexo&lt;/a&gt;
    
    </summary>
    
      <category term="生活" scheme="http://kinegratii.github.io/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
  </entry>
  
  <entry>
    <title>使用DaoCloud部署Django项目</title>
    <link href="http://kinegratii.github.io/2016/07/23/daocloud-django-deploy/"/>
    <id>http://kinegratii.github.io/2016/07/23/daocloud-django-deploy/</id>
    <published>2016-07-23T06:56:00.000Z</published>
    <updated>2016-11-01T12:43:20.336Z</updated>
    
    <content type="html"><![CDATA[<p>本文介绍了在DaoCloud平台部署Django项目的方法。</p>
<a id="more"></a>
<h2 id="1-DaoCloud云平台"><a href="#1-DaoCloud云平台" class="headerlink" title="1 DaoCloud云平台"></a>1 DaoCloud云平台</h2><p>关于DaoCloud云平台。<a href="https://www.daocloud.io/" target="_blank" rel="external">https://www.daocloud.io/</a></p>
<blockquote>
<p>DaoCloud 为用户提供了 Docker 镜像的自动构建和自动发布功能，当用户完成了 Dockerfile 和 daocloud.yml 文件的编写后，将应用代码推送到第三方代码托管平台上，将其与 DaoCloud 绑定后，在每次修改（commit）后，并将其推送到代码托管平台上，DaoCloud 会检测到代码的变动，并根据 Dockerfile 和 daocloud.yml 进行相应的构建和测试；当触发规定的构建事件（如 tag）时，DaoCloud 会将其进行镜像构建，并推送到相对应的所有生产环节中。</p>
</blockquote>
<h2 id="2-Django项目配置"><a href="#2-Django项目配置" class="headerlink" title="2 Django项目配置"></a>2 Django项目配置</h2><p>项目总布局如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">- wcp_platform/</div><div class="line">  - admin.py</div><div class="line">  - forms.py</div><div class="line">  - models.py</div><div class="line">  - views.py</div><div class="line">- wcp/</div><div class="line">  - daocloud_settings.py</div><div class="line">  - daocloud_wsgi.py</div><div class="line">  - settings.py</div><div class="line">  - test_settings.py</div><div class="line">  - urls.py</div><div class="line">  - wsgi.py</div><div class="line">- fixtures/</div><div class="line">  - user.json</div><div class="line">- static/</div><div class="line">- template/</div><div class="line">- Dockerfile</div><div class="line">- daocloud.yml</div><div class="line">- docker-entrypoint.sh</div><div class="line">- manage.py</div><div class="line">- requirements.txt</div></pre></td></tr></table></figure>
<h2 id="3-基于daocloud的配置"><a href="#3-基于daocloud的配置" class="headerlink" title="3 基于daocloud的配置"></a>3 基于daocloud的配置</h2><h3 id="3-1-daocloud-settings模块"><a href="#3-1-daocloud-settings模块" class="headerlink" title="3.1 daocloud_settings模块"></a>3.1 daocloud_settings模块</h3><p>daocloud_settings模块重写了数据库配置（这里使用了mysql服务）和wsgi配置模块。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">from __future__ import unicode_literals</div><div class="line">from .settings import *</div><div class="line">DATABASES = &#123;</div><div class="line">    &apos;default&apos;: &#123;</div><div class="line">        &apos;ENGINE&apos;: &apos;django.db.backends.mysql&apos;,</div><div class="line">        &apos;NAME&apos;: os.environ[&apos;MYSQL_INSTANCE_NAME&apos;],</div><div class="line">        &apos;USER&apos;: os.environ[&apos;MYSQL_USERNAME&apos;],</div><div class="line">        &apos;PASSWORD&apos;: os.environ[&apos;MYSQL_PASSWORD&apos;],</div><div class="line">        &apos;HOST&apos;: os.environ[&apos;MYSQL_PORT_3306_TCP_ADDR&apos;],</div><div class="line">        &apos;PORT&apos;: os.environ[&apos;MYSQL_PORT_3306_TCP_PORT&apos;],</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">WSGI_APPLICATION = wcp.daocloud_wsgi.application&apos;</div></pre></td></tr></table></figure>
<h3 id="3-2-daocloud-wsgi模块"><a href="#3-2-daocloud-wsgi模块" class="headerlink" title="3.2 daocloud_wsgi模块"></a>3.2 daocloud_wsgi模块</h3><p>daocloud_wsgi.py模块设置了环境变量。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">from __future__ import unicode_literals</div><div class="line">import os</div><div class="line">from django.core.wsgi import get_wsgi_application</div><div class="line">os.environ.setdefault(&quot;DJANGO_SETTINGS_MODULE&quot;, &quot;wcp.daocloud_settings&quot;)</div><div class="line">application = get_wsgi_application()</div></pre></td></tr></table></figure>
<h3 id="3-3-Dockerfile"><a href="#3-3-Dockerfile" class="headerlink" title="3.3 Dockerfile"></a>3.3 Dockerfile</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">FROM daocloud.io/python:2.7</div><div class="line">ADD requirements.txt /tmp/requirements.txt</div><div class="line">RUN pip install -r /tmp/requirements.txt</div><div class="line">RUN mkdir /code</div><div class="line">WORKDIR /code</div><div class="line">COPY . /code</div><div class="line">COPY docker-entrypoint.sh docker-entrypoint.sh</div><div class="line">RUN chmod +x docker-entrypoint.sh</div><div class="line">EXPOSE 8080</div><div class="line">CMD /code/docker-entrypoint.sh</div></pre></td></tr></table></figure>
<p>具体流程</p>
<ul>
<li>安装依赖库</li>
<li>拷贝项目代码</li>
<li>修改<code>docker-entrypoint.sh</code>权限为可执行</li>
<li>开放端口</li>
<li>执行<code>docker-entrypoint.sh</code></li>
</ul>
<h3 id="3-4-启动脚本"><a href="#3-4-启动脚本" class="headerlink" title="3.4 启动脚本"></a>3.4 启动脚本</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">ython /code/manage.py migrate --settings=wcp.daocloud_settings --noinput</div><div class="line">python /code/manage.py collectstatic -- settings=wcp.daocloud_settings --noinput</div><div class="line">/usr/local/bin/gunicorn wcp.daocloud_wsgi:application -w 2 -b :8080 --env DJANGO_SETTINGS_MODULE=&apos;wcp.daocloud_settings&apos;</div></pre></td></tr></table></figure>
<p>启动流程</p>
<ul>
<li>创建数据表</li>
<li>收集静态文件</li>
<li>使用gunicorn启动Django项目</li>
</ul>
<h3 id="3-5-持续集成：daocloud-yml"><a href="#3-5-持续集成：daocloud-yml" class="headerlink" title="3.5 持续集成：daocloud.yml"></a>3.5 持续集成：daocloud.yml</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">image: daocloud/ci-python:2.7</div><div class="line">script:</div><div class="line">  - pip install -r requirements.txt</div><div class="line">  - python manage.py test --settings=wcp.test_settings</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文介绍了在DaoCloud平台部署Django项目的方法。&lt;/p&gt;
    
    </summary>
    
      <category term="编程" scheme="http://kinegratii.github.io/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Django" scheme="http://kinegratii.github.io/tags/Django/"/>
    
      <category term="DaoCloud" scheme="http://kinegratii.github.io/tags/DaoCloud/"/>
    
      <category term="部署" scheme="http://kinegratii.github.io/tags/%E9%83%A8%E7%BD%B2/"/>
    
  </entry>
  
  <entry>
    <title>python打包工具</title>
    <link href="http://kinegratii.github.io/2016/04/23/python-package/"/>
    <id>http://kinegratii.github.io/2016/04/23/python-package/</id>
    <published>2016-04-23T00:34:21.000Z</published>
    <updated>2016-11-01T12:45:51.772Z</updated>
    
    <content type="html"><![CDATA[<p>本文介绍了py2exe、cx_freeze和PyInstaller这三种Python打包工具的使用方法。</p>
<a id="more"></a>
<h2 id="1-Python打包工具"><a href="#1-Python打包工具" class="headerlink" title="1 Python打包工具"></a>1 Python打包工具</h2><p>目前在windows平台上将Python程序打包成exe文件主要有三个工具。</p>
<ul>
<li>py2exe <a href="http://www.py2exe.org/" target="_blank" rel="external">http://www.py2exe.org/</a></li>
<li>cx_freeze <a href="http://cx-freeze.sourceforge.net/" target="_blank" rel="external">http://cx-freeze.sourceforge.net/</a></li>
<li>PyInstaller <a href="http://pythonhosted.org/PyInstaller/" target="_blank" rel="external">http://pythonhosted.org/PyInstaller/</a></li>
</ul>
<p>今天将一个Tkinter写的界面程序打包成exe文件，三个工具都试了一遍，感觉PyInstaller会比较好用一些。</p>
<h2 id="2-py2exe"><a href="#2-py2exe" class="headerlink" title="2 py2exe"></a>2 py2exe</h2><h3 id="2-1-下载安装"><a href="#2-1-下载安装" class="headerlink" title="2.1 下载安装"></a>2.1 下载安装</h3><p>从这里<a href="https://sourceforge.net/projects/py2exe/files/py2exe/0.6.9/" target="_blank" rel="external">https://sourceforge.net/projects/py2exe/files/py2exe/0.6.9/</a> 选择python版本和计算机位数对应的exe文件，双击即可安装。</p>
<h3 id="2-2-启动脚本"><a href="#2-2-启动脚本" class="headerlink" title="2.2 启动脚本"></a>2.2 启动脚本</h3><p>写一个setup_py2exe.py文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">from distutils.core import setup</div><div class="line">import py2exe</div><div class="line">options = &#123;&apos;py2exe&apos;: &#123;&apos;compressed&apos;: 1,</div><div class="line">                      &apos;optimize&apos;: 2,</div><div class="line">                      &apos;bundle_files&apos;: 1, &#125;&#125;</div><div class="line">setup(name=&apos;App&apos;,</div><div class="line">      author=&apos;kinegratii&apos;,</div><div class="line">      version=&apos;1.0.0&apos;,</div><div class="line">      options=options,</div><div class="line">      windows=[&#123;&quot;script&quot;: &quot;app.py&quot;&#125;],</div><div class="line">      zipfile=None</div><div class="line">      )</div></pre></td></tr></table></figure>
<h3 id="2-3-命令"><a href="#2-3-命令" class="headerlink" title="2.3 命令"></a>2.3 命令</h3><p>执行python setup_py2exe.py py2exe即可，dist目录就是最后生成的结果。</p>
<h3 id="2-4-Q-amp-A"><a href="#2-4-Q-amp-A" class="headerlink" title="2.4 Q&amp;A"></a>2.4 Q&amp;A</h3><p><strong>import py2exe</strong></p>
<p><code>import py2exe</code>这个语句要保留，因为用PyCharm自动格式化的时候总会把这个语句优化掉。</p>
<p><strong>UnicodeDecodeError异常</strong></p>
<p>之前加了<code>from __future__ import unicode_literals</code>这个语句，会报<code>UnicodeDecodeError: &#39;utf8&#39; codec can&#39;t decode byte 0xd1 in position 3: invalid continuation byte</code></p>
<p><strong>lxml库</strong></p>
<p>程序报的异常是<code>ImportError: No module named lxml._elementpath</code>，但按照网上的说法加了includes参数可以解决。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">options=&#123;</div><div class="line">    &apos;py2exe&apos;: &#123;</div><div class="line">        &apos;includes&apos;: [&apos;lxml.etree&apos;, &apos;lxml._elementpath&apos;, &apos;gzip&apos;],</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>TypeError: expected string or buffer</strong></p>
<p>这个异常是docx这个库出现的。找了很久还没有什么头绪。</p>
<h2 id="3-cx-freeze"><a href="#3-cx-freeze" class="headerlink" title="3 cx_freeze"></a>3 cx_freeze</h2><h3 id="3-1-pip安装"><a href="#3-1-pip安装" class="headerlink" title="3.1 pip安装"></a>3.1 pip安装</h3><p>执行pip命令即可安装</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pip install cx_Freeze</div></pre></td></tr></table></figure>
<h3 id="3-2-启动脚本"><a href="#3-2-启动脚本" class="headerlink" title="3.2 启动脚本"></a>3.2 启动脚本</h3><p>setup_cx.py文件如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">from __future__ import unicode_literals</div><div class="line">import sys</div><div class="line">from cx_Freeze import setup, Executable</div><div class="line">base = None</div><div class="line">if sys.platform == &quot;win32&quot;:</div><div class="line">    base = &quot;Win32GUI&quot;</div><div class="line">includeFiles = [</div><div class="line">    (r&quot;D:\py\tcl\tcl8.5&quot;, &quot;tcl&quot;),</div><div class="line">    (r&quot;D:\py\tcl\tk8.5&quot;, &quot;tk&quot;)</div><div class="line">]</div><div class="line">setup(</div><div class="line">    name=&quot;App&quot;,</div><div class="line">    version=&quot;1.0&quot;,</div><div class="line">    description=&quot;A demo app&quot;,</div><div class="line">    options=&#123;&quot;build_exe&quot;: &#123;&quot;include_files&quot;: includeFiles, &#125;&#125;,</div><div class="line">    executables=[Executable(&quot;app.py&quot;, base=base, includes=[&apos;lxml&apos;, &apos;lxml.tree&apos;, &apos;lxml._namepath&apos;])]</div><div class="line">)</div></pre></td></tr></table></figure>
<h3 id="3-3-命令"><a href="#3-3-命令" class="headerlink" title="3.3 命令"></a>3.3 命令</h3><p>执行命令python setup_cx.py build，dist下的exe.开头的文件夹（名字跟具体环境有关，比如我的是exe.win32-2.7）就是最后的生成的文件夹。</p>
<h3 id="3-4-Q-amp-A"><a href="#3-4-Q-amp-A" class="headerlink" title="3.4 Q&amp;A"></a>3.4 Q&amp;A</h3><p><strong>lxml</strong></p>
<p>也需要明确包含<code>lxml._elementpath</code></p>
<p><strong>docx</strong></p>
<p>也出现了和py2exe一样的异常。</p>
<h2 id="4-PyInstaller"><a href="#4-PyInstaller" class="headerlink" title="4 PyInstaller"></a>4 PyInstaller</h2><h3 id="4-1-pip安装"><a href="#4-1-pip安装" class="headerlink" title="4.1  pip安装"></a>4.1  pip安装</h3><p>执行pip安装</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pip install pyinstaller</div></pre></td></tr></table></figure>
<p>安装成功后在python的目录下\Scripts文件夹多出pyinstaller.exe、pyinstaller.exe.manifest、pyinstaller-script.py等几个文件。</p>
<h3 id="4-2-命令方式构建"><a href="#4-2-命令方式构建" class="headerlink" title="4.2 命令方式构建"></a>4.2 命令方式构建</h3><p>把Scripts目录加到系统的环境变量中，cd到脚本所在的目录，然后执行下面的命令。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pyinstaller app.py -F -w --clean</div></pre></td></tr></table></figure>
<p>app.py 脚本文件</p>
<p>几个选项含义</p>
<ul>
<li>-F 打包为单一文件，和打包为一个文件夹相对，默认为后者</li>
<li>-w 窗口程序，与控制台相对</li>
<li>–clean 每次清理中间产生的构建文件</li>
</ul>
<p>生成的相关文件包括</p>
<ul>
<li>app.spec 配置文件</li>
<li>build文件夹 构建中产生的中间文件</li>
<li>dist/app文件夹 这里的文件都是运行所需要的</li>
</ul>
<h3 id="4-3-启动脚本方式"><a href="#4-3-启动脚本方式" class="headerlink" title="4.3 启动脚本方式"></a>4.3 启动脚本方式</h3><p>命令行带太多参数的话，每次都要输入，比较麻烦，可以统统写在一个py脚本中。</p>
<p>PyInstaller也是一个标准的Python包，提供了<code>PyInstaller.main.run</code>这个方法。</p>
<p>4.2节中等效的python脚本如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">if __name__ == &apos;__main__&apos;:</div><div class="line">    from PyInstaller.main import run</div><div class="line">    params=[app.py&apos;, &apos;-F&apos;, &apos;-w&apos;, &apos;--clean&apos;]</div><div class="line">    run(params)</div></pre></td></tr></table></figure>
<p>用Python解释器执行这个脚本就可以了。</p>
<h3 id="4-4-Q-amp-A"><a href="#4-4-Q-amp-A" class="headerlink" title="4.4 Q&amp;A"></a>4.4 Q&amp;A</h3><p><strong>lxml</strong></p>
<p>可以解决lxml包含的问题，无需明确指定</p>
<p><strong>调试</strong></p>
<p>由于用了没有控制台的-w方式，如果程序启动有错的话，只会弹出app return -1的对话框，没有具体异常信息。可以先去掉-w，用控制台进行调试，所有的异常和程序中的print函数就显示在控制台上，方便调试。</p>
<p><strong>单exe资源文件路径问题</strong></p>
<p>这个问题应该只要是最后打包成单个exe都会出现的问题。描述如下</p>
<p>最后打包的文件结构如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">- XxxApp</div><div class="line">    - app.exe</div><div class="line">    - data</div><div class="line">        - wpa.db</div></pre></td></tr></table></figure>
<p>程序中用下面语句引用wpa.db文件，会出现文件打不开的情况</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">BASE_DIR = os.path.abspath(os.path.dirname(__file__))</div><div class="line">DB_FILE = os.path.join(BASE_DIR,&apos;data&apos;, &apos;wpa.db&apos;)</div></pre></td></tr></table></figure>
<p>调试打印出<code>BASE_DIR</code>，发现路径不是XxxApp，而是在用户目录下的某一个位置，类似如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">c:\Users\kinegratii\AppData&apos;Local\Temp\_MEI11~1\dadta\wpa.db</div></pre></td></tr></table></figure>
<p>这是因为<strong>在单文件模式中运行程序的时候先将文件解压到sys._MEIPASS指向的目录下，所以引用资源文件就需要添加os.path.join(sys._MEIPASS,filename)</strong>，</p>
<p>第一种方法，具体判断程序当前模式。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">if getattr(sys, &apos;frozen&apos;, False):</div><div class="line">      BASE_DIR = sys._MEIPASS</div><div class="line">  else:</div><div class="line">      BASE_DIR = os.path.dirname(__file__)</div></pre></td></tr></table></figure>
<p>第二种，就是将<code>__file__</code>改为sys.args[0]，即</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">BASE_DIR = os.path.abspath(os.path.dirname(sys.argv[0]))</div></pre></td></tr></table></figure>
<p>这样打印的路径就是正确的了，原因在于<code>__file__</code>和<code>sys.args[0]</code>有点区别。</p>
<blockquote>
<p><code>__file__</code> is the name of the current file, which may be different from the main script if you are inside a module or if you start a script using execfile() rather than by invoking python scriptname.py.  <code>__file__</code> is generally your safer bet.</p>
</blockquote>
<p>来自 <a href="http://stackoverflow.com/a/5851608" target="_blank" rel="external">http://stackoverflow.com/a/5851608</a></p>
<p><strong>icon图标无法显示问题</strong></p>
<p>使用icon选项即可添加图标，但有时候发现资源管理器的图标可以显示，但运行程序后任务栏上的图标却无法显示。关于这个问题 。</p>
<blockquote>
<p>在不同情况下（比如资源管理器文件列表前面的图标、桌面、开始菜单等）需要不一样尺寸的图标。如果尺寸不合适的话，可能出现有的地方显示正确有的显示不正确的情况。最后几个地方都要检查一遍。</p>
</blockquote>
<p>解决方案</p>
<blockquote>
<p>应该准备四张不同尺寸（具体尺寸参见 <a href="http://stackoverflow.com/questions/3236115/which-icon-sizes-should-my-windows-applications-icon-include" target="_blank" rel="external">http://stackoverflow.com/questions/3236115/which-icon-sizes-should-my-windows-applications-icon-include</a> ）的png文件<br>用png2icon脚本把它们合成一张icon图标文件即可</p>
</blockquote>
<h2 id="5-参考资料"><a href="#5-参考资料" class="headerlink" title="5 参考资料"></a>5 参考资料</h2><ul>
<li>py2exe lxml error <a href="http://stackoverflow.com/a/5309733" target="_blank" rel="external">http://stackoverflow.com/a/5309733</a></li>
<li>Creating an Executable from a Python Script | Matt Borgerson<br><a href="https://mborgerson.com/creating-an-executable-from-a-python-script" target="_blank" rel="external">https://mborgerson.com/creating-an-executable-from-a-python-script</a></li>
<li>pyinstaller打包pyqt文件 - dcb3688 - 博客园<br><a href="http://www.cnblogs.com/dcb3688/p/4211390.html" target="_blank" rel="external">http://www.cnblogs.com/dcb3688/p/4211390.html</a></li>
<li>使用pyinstaller打包python程序 - 魏哲的空间<br><a href="https://blog.weizhe.net/?p=412" target="_blank" rel="external">https://blog.weizhe.net/?p=412</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文介绍了py2exe、cx_freeze和PyInstaller这三种Python打包工具的使用方法。&lt;/p&gt;
    
    </summary>
    
      <category term="编程" scheme="http://kinegratii.github.io/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Python" scheme="http://kinegratii.github.io/tags/Python/"/>
    
      <category term="构建" scheme="http://kinegratii.github.io/tags/%E6%9E%84%E5%BB%BA/"/>
    
  </entry>
  
  <entry>
    <title>pytz东八区6分钟问题</title>
    <link href="http://kinegratii.github.io/2015/11/12/python-pytz-6-minutes/"/>
    <id>http://kinegratii.github.io/2015/11/12/python-pytz-6-minutes/</id>
    <published>2015-11-12T13:47:00.000Z</published>
    <updated>2016-11-01T12:53:44.931Z</updated>
    
    <content type="html"><![CDATA[<p>本文介绍了pytz库中 <code>Asia/Shanghai</code>时区相差6分钟的问题。</p>
<a id="more"></a>
<p>之前也一直没有注意到这个问题，最近的项目需要同时显示DTU设备时间和服务器时间，才发现设备时间总是少6-7分钟。<br>在项目中，两者解析成datetime对象的使用方法不一样：</p>
<ul>
<li>服务器用的是Django框架，使用了django.utils.timezone.now函数解析服务器当前时间</li>
<li>DTU则是自己通过构造函数创建的，时区用的是pytz.timezone(‘Asia/Shanghai’)</li>
</ul>
<p>首先在一篇文章<a href="http://www.keakon.net/2010/12/14/%E7%94%A8datetime%E5%92%8Cpytz%E6%9D%A5%E8%BD%AC%E6%8D%A2%E6%97%B6%E5%8C%BA" target="_blank" rel="external">《用datetime和pytz来转换时区》</a>中说可以用台北时间（Asia/Taipei），试验下发现台北时间也有6分钟的问题。为了测试通过临时强制加上了6分钟，才勉强通过测试，然而这不是长久之计。</p>
<p>晚上下班时回家用“pytz 6分钟”搜索发现了<a href="http://www.laonan.net/blog/G681_FUNEeWTK_79rf__Vw/" target="_blank" rel="external">《python中pytz,东8区,6分钟问题 - 老楠老楠》</a>这篇文章。<strong>根据文章的描述，用localize函数就可以了。</strong></p>
<p>使用datetime直接构造时间的时候，设置时区是没有北京时间的，一般来说习惯了linux的同志都会默认用上海时间来代替，这里却有一个问题，如果要进行时区转换，上海时间比北京时间差6分钟。。。</p>
<p>比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">tz = pytz.timezone(&apos;Asia/Shanghai&apos;)</div><div class="line">t = datetime.datetime(2015, 9, 5, 9, 0, 0, 0, tzinfo=tz)</div></pre></td></tr></table></figure>
<p>这样打印出来得到的时间是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">2015-09-07 09:00:00+08:06</div></pre></td></tr></table></figure>
<p>在django框架中，貌似from django.utils.timezone import localtime的这个localtime会修正那6分钟，这问题就来了，要自己在程序里构造时间，并且跟用这个localtime转化的时间对比的时候巨麻烦。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文介绍了pytz库中 &lt;code&gt;Asia/Shanghai&lt;/code&gt;时区相差6分钟的问题。&lt;/p&gt;
    
    </summary>
    
      <category term="编程" scheme="http://kinegratii.github.io/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="pytz" scheme="http://kinegratii.github.io/tags/pytz/"/>
    
  </entry>
  
  <entry>
    <title>Python IP归属地查询</title>
    <link href="http://kinegratii.github.io/2015/08/30/python-ip-query/"/>
    <id>http://kinegratii.github.io/2015/08/30/python-ip-query/</id>
    <published>2015-08-30T14:04:21.000Z</published>
    <updated>2016-11-01T12:51:07.719Z</updated>
    
    <content type="html"><![CDATA[<p>基于Python3.2 + tkinter + 淘宝IP API的IP归属地查询。</p>
<a id="more"></a>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div></pre></td><td class="code"><pre><div class="line">from tkinter import *</div><div class="line">import re</div><div class="line">import urllib</div><div class="line">import urllib.request</div><div class="line">import json</div><div class="line">item = (&apos;country&apos;,&apos;area&apos;,&apos;region&apos;,&apos;city&apos;,&apos;isp&apos;)</div><div class="line">itemVar = (&apos;国家&apos;,&apos;地区&apos;,&apos;省&apos;,&apos;市&apos;,&apos;运营商&apos;)</div><div class="line">class MWindow(Frame):</div><div class="line">    def __init__(self):</div><div class="line">        Frame.__init__(self)</div><div class="line">        self.master.title(&apos;IPSearch&apos;)</div><div class="line">        self.master.geometry(&apos;700x400&apos;)</div><div class="line">        self.pack(side = TOP,expand = YES,fill = BOTH)</div><div class="line">        ioPut = &#123;&#125;</div><div class="line">        ioPut[&apos;ip_input&apos;] = StringVar()</div><div class="line">        ioPut[&apos;result_ouput&apos;] = StringVar()</div><div class="line">        res = &#123;&#125;</div><div class="line">        for vx in item:</div><div class="line">            res[vx] = StringVar()</div><div class="line">        # top Frame</div><div class="line">        topF = self.createFrame(self,TOP)</div><div class="line">        inL = self.createLabel(topF,TOP,&apos;请输入IP地址：&apos;)</div><div class="line">        ipE = self.createEntry(topF,TOP,ioPut[&apos;ip_input&apos;])</div><div class="line">        resL = self.createLabel(topF,TOP,&apos;查询结果：&apos;)</div><div class="line">        resE = self.createEntry(topF,TOP,ioPut[&apos;result_ouput&apos;])</div><div class="line">        #mid Frame</div><div class="line">        midF = self.createFrame(self,TOP)</div><div class="line">        i = 0</div><div class="line">        l = len(item)</div><div class="line">        while i &lt; l:</div><div class="line">            L = self.createLabel(midF,LEFT,itemVar[i])</div><div class="line">            E = self.createEntry(midF,LEFT,res[item[i]])</div><div class="line">            i = i + 1</div><div class="line">        #bottom Frame</div><div class="line">        botF = self.createFrame(self,TOP)</div><div class="line">        searchB = Button(botF,text = &apos;search&apos;,</div><div class="line">                         command = lambda ioPut = ioPut,res = res:self.IpSearch(ioPut,res))</div><div class="line">        searchB.pack(side = TOP,expand = YES,fill = BOTH)</div><div class="line">    def createFrame(self,parent,side):</div><div class="line">        f = Frame(parent)</div><div class="line">        f.pack(side = side,expand = YES,fill = BOTH)</div><div class="line">        return f</div><div class="line">    def createLabel(self,parent,side,text):</div><div class="line">        l = Label(parent,text = text)</div><div class="line">        l.pack(side = side,expand = YES)</div><div class="line">        return l</div><div class="line">    def createEntry(self,parent,side,textvariable):</div><div class="line">        e = Entry(parent,relief = SUNKEN,textvariable = textvariable,width = 15)</div><div class="line">        e.pack(side = side,expand = NO)</div><div class="line">        return e</div><div class="line">    def IpSearch(self,ioPut,res):</div><div class="line">        ipRex = &apos;((?:(?:25[0-5]|2[0-4]\d|((1\d&#123;2&#125;)|([1-9]?\d)))\.)&#123;3&#125;(?:25[0-5]|2[0-4]\d|((1\d&#123;2&#125;)|([1-9]?\d))))&apos;</div><div class="line">        ip = ioPut[&apos;ip_input&apos;].get()</div><div class="line">        tmp = re.findall(re.compile(ipRex),ip)</div><div class="line">        if not tmp:</div><div class="line">            ioPut[&apos;result_ouput&apos;].set(&apos;ip格式错误，请重新输入&apos;)</div><div class="line">            return</div><div class="line">        reponseData = IpS().searchByTaobao(ip)</div><div class="line">        data = json.loads(reponseData)</div><div class="line">        if data[&apos;code&apos;] == 0:</div><div class="line">            ioPut[&apos;result_ouput&apos;].set(&apos;该IP所在位置如下&apos;)</div><div class="line">        else:</div><div class="line">            ioPut[&apos;result_ouput&apos;].set(&apos;找不到相关信息&apos;)</div><div class="line">        d = data[&apos;data&apos;]</div><div class="line">        for vx in item:</div><div class="line">            res[vx].set(d[vx])</div><div class="line">class IpS():</div><div class="line">    def __init__(self):</div><div class="line">        self.apiUrlTaobao = &apos;http://ip.taobao.com/service/getIpInfo.php?ip=&apos;</div><div class="line">    def searchByTaobao(self,ip):</div><div class="line">        headers = (&apos;User-Agent&apos;,&apos;Mozilla/5.0 (Windows NT 5.1; rv:14.0) Gecko/20100101 Firefox/14.0.1&apos;)</div><div class="line">        opener = urllib.request.build_opener()</div><div class="line">        opener.addheaders = [headers]</div><div class="line">        data = opener.open(self.apiUrlTaobao+ip).read()</div><div class="line">        data = data.decode(&apos;UTF-8&apos;)</div><div class="line">        return data</div><div class="line">if __name__ == &apos;__main__&apos;:</div><div class="line">    MWindow().mainloop()</div></pre></td></tr></table></figure>
<h2 id="效果图"><a href="#效果图" class="headerlink" title="效果图"></a>效果图</h2><p><img src="/images/python-ip-query.png" alt="pythonIP归属地查询"></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;基于Python3.2 + tkinter + 淘宝IP API的IP归属地查询。&lt;/p&gt;
    
    </summary>
    
      <category term="编程" scheme="http://kinegratii.github.io/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Python" scheme="http://kinegratii.github.io/tags/Python/"/>
    
  </entry>
  
</feed>
